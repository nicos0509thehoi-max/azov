--meow
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local CoreGui = game:GetService("CoreGui")
local StarterGui = game:GetService("StarterGui")
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
-- ╔═══════════════════════╗
-- ║ KEY SYSTEM ║
-- ╚═══════════════════════╝
local CORRECT_KEY = "azv" 
local KeyGui = Instance.new("ScreenGui")
KeyGui.Name = "KeySystemGui"
KeyGui.Parent = CoreGui
KeyGui.ResetOnSpawn = false
local MainFrame = Instance.new("Frame")
MainFrame.Parent = KeyGui
MainFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
MainFrame.Size = UDim2.new(0, 600, 0, 300)
MainFrame.Position = UDim2.new(0.5, -300, 0.5, -150)
MainFrame.ClipsDescendants = true
local TitleBar = Instance.new("Frame")
TitleBar.Parent = MainFrame
TitleBar.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
TitleBar.Size = UDim2.new(1, 0, 0, 28)
TitleBar.Active = true
local TitleText = Instance.new("TextLabel")
TitleText.Parent = TitleBar
TitleText.BackgroundTransparency = 1
TitleText.Size = UDim2.new(0, 150, 1, 0)
TitleText.Position = UDim2.new(0, 10, 0, 0)
TitleText.Text = "Azov .gg/cack5ZaXrE"
TitleText.Font = Enum.Font.SourceSansBold
TitleText.TextColor3 = Color3.fromRGB(255, 255, 255)
TitleText.TextSize = 18
local CloseButton = Instance.new("TextButton")
CloseButton.Parent = TitleBar
CloseButton.Size = UDim2.new(0, 40, 0, 28)
CloseButton.Position = UDim2.new(1, -40, 0, 0)
CloseButton.BackgroundTransparency = 1
CloseButton.Text = "X"
CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseButton.TextSize = 18
CloseButton.MouseButton1Click:Connect(function()
    KeyGui:Destroy()
end)
local AsciiArt = Instance.new("TextLabel")
AsciiArt.Parent = MainFrame
AsciiArt.BackgroundTransparency = 1
AsciiArt.Size = UDim2.new(1, 0, 0.6, 0)
AsciiArt.Position = UDim2.new(0, 0, 0.12, 0)
AsciiArt.Font = Enum.Font.Code
AsciiArt.Text = [[
 (`-')  _   (`-')                   (`-')
 (OO ).-/   ( OO).->    .->        _(OO )
 / ,---.  ,(_/----.(`-')----. ,--.(_/,-.\
 | \ /`.\ |__,    |( OO).-.  '\   \ / (_/
 '-'|_.' | (_/   / ( _) | |  | \   /   / 
(|  .-.  | .'  .'_  \|  |)|  |_ \     /_)
 |  | |  ||       |  '  '-'  '\-'\   /   
 `--' `--'`-------'   `-----'     `-'    
]]
AsciiArt.TextColor3 = Color3.fromRGB(112, 0, 0)
AsciiArt.TextSize = 12
AsciiArt.TextWrapped = true
AsciiArt.TextXAlignment = Enum.TextXAlignment.Center
local KeyLabel = Instance.new("TextLabel")
KeyLabel.Parent = MainFrame
KeyLabel.BackgroundTransparency = 1
KeyLabel.Position = UDim2.new(0, 30, 0, 200)
KeyLabel.Size = UDim2.new(0.7, 0, 0.1, 0)
KeyLabel.Font = Enum.Font.Code
KeyLabel.RichText = true
KeyLabel.TextColor3 = Color3.fromRGB(128, 128, 128)
KeyLabel.TextSize = 14
KeyLabel.TextXAlignment = Enum.TextXAlignment.Left
-- Dragging
local dragging, dragInput, dragStart, startPos
TitleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = MainFrame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then dragging = false end
        end)
    end
end)
TitleBar.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)
UserInputService.InputChanged:Connect(function(input)
    if dragging and input == dragInput then
        local delta = input.Position - dragStart
        MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)
-- Key system logic
local typedKey = ""
local showCursor = true
local canType = false
local authenticated = false
local function updateLabel()
    local cursor = showCursor and "▄" or ""
    KeyLabel.Text = string.format('[<font color="rgb(255,0,0)">-</font>] Key: <font color="rgb(128,128,128)">%s</font><font color="rgb(255,255,255)">%s</font>', typedKey, cursor)
end
task.spawn(function()
    while not authenticated do
        showCursor = not showCursor
        updateLabel()
        task.wait(0.5)
    end
end)
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if canType and input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == Enum.KeyCode.Return then
            canType = false
            if typedKey:lower() == CORRECT_KEY:lower() then
                authenticated = true
                KeyLabel.Text = '[<font color="rgb(0,255,0)">+</font>] Authenticating...'
                task.wait(2)
                local function fade(gui, dur)
                    for _, o in ipairs(gui:GetDescendants()) do
                        if o:IsA("GuiObject") then
                            TweenService:Create(o, TweenInfo.new(dur), {Transparency = 1, BackgroundTransparency = 1}):Play()
                            if o:IsA("TextLabel") or o:IsA("TextButton") then
                                TweenService:Create(o, TweenInfo.new(dur), {TextTransparency = 1}):Play()
                            end
                        end
                    end
                end
                fade(KeyGui, 1.5)
                task.wait(1.5)
                KeyGui:Destroy()
                print("Key accepted! Loading full script...")
                loadFeatures()
            else
                LocalPlayer:Kick("Invalid Key")
            end
        elseif input.KeyCode == Enum.KeyCode.Backspace then
            typedKey = typedKey:sub(1, -2)
        else
            local name = input.KeyCode.Name
            if #name == 1 then
                typedKey = typedKey .. name:lower()
            end
        end
        updateLabel()
    end
end)
UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType ~= Enum.UserInputType.MouseButton1 and input.UserInputType ~= Enum.UserInputType.Touch then return end
    local pos = input.Position
    local absPos = KeyLabel.AbsolutePosition
    local absSize = KeyLabel.AbsoluteSize
    if pos.X >= absPos.X and pos.X <= absPos.X + absSize.X and pos.Y >= absPos.Y and pos.Y <= absPos.Y + absSize.Y then
        canType = true
        typedKey = ""
        updateLabel()
    else
        canType = false
        updateLabel()
    end
end)
updateLabel()
-- ╔═══════════════════════════════════════════╗
-- ║ YOUR FULL SCRIPT LOADS HERE ║
-- ╚═══════════════════════════════════════════╝
function loadFeatures()
    -- Speed Boost (V) + Super Jump (Z hold)
    local SpeedEnabled = false
    local DefaultWalkSpeed = 16
    local DefaultJumpPower = 50
    local BoostWalkSpeed = 500
    local BoostJumpPower = 200
    local function onCharAdded(char)
        local hum = char:WaitForChild("Humanoid")
        hum.WalkSpeed = DefaultWalkSpeed
        hum.JumpPower = DefaultJumpPower
    end
    LocalPlayer.CharacterAdded:Connect(onCharAdded)
    if LocalPlayer.Character then onCharAdded(LocalPlayer.Character) end
    UserInputService.InputBegan:Connect(function(input, gp)
        if gp then return end
        if input.KeyCode == Enum.KeyCode.V then
            SpeedEnabled = not SpeedEnabled
            print("Speed Boost:", SpeedEnabled and "ON (500 SPS)" or "OFF")
        end
    end)
    RunService.RenderStepped:Connect(function()
        local char = LocalPlayer.Character
        if not char then return end
        local hum = char:FindFirstChildOfClass("Humanoid")
        if not hum then return end
        hum.WalkSpeed = SpeedEnabled and BoostWalkSpeed or DefaultWalkSpeed
        hum.JumpPower = UserInputService:IsKeyDown(Enum.KeyCode.Z) and BoostJumpPower or DefaultJumpPower
    end)
    -- ESP (Highlight + Name + Health + Box)
    local ESPObjects = {}
    local function addESP(char)
        if char == LocalPlayer.Character then return end
        if ESPObjects[char] then return end
        local highlight = Instance.new("Highlight")
        highlight.FillColor = Color3.fromRGB(0, 0, 255)
        highlight.OutlineColor = Color3.fromRGB(120, 81, 169)
        highlight.FillTransparency = 0.5
        highlight.OutlineTransparency = 0
        highlight.Adornee = char
        highlight.Parent = char
        local head = char:WaitForChild("Head")
        local billboard = Instance.new("BillboardGui")
        billboard.Adornee = head
        billboard.Size = UDim2.new(0, 200, 0, 50)
        billboard.StudsOffset = Vector3.new(0, 3, 0)
        billboard.AlwaysOnTop = true
        billboard.Parent = head
        local nameLabel = Instance.new("TextLabel")
        nameLabel.BackgroundTransparency = 1
        nameLabel.Size = UDim2.new(1, 0, 0.5, 0)
        nameLabel.Text = char.Name
        nameLabel.TextColor3 = Color3.new(1, 1, 1)
        nameLabel.TextStrokeTransparency = 0
        nameLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
        nameLabel.Font = Enum.Font.Code
        nameLabel.TextSize = 14
        nameLabel.Parent = billboard
        local healthLabel = Instance.new("TextLabel")
        healthLabel.BackgroundTransparency = 1
        healthLabel.Size = UDim2.new(1, 0, 0.5, 0)
        healthLabel.Position = UDim2.new(0, 0, 0.5, 0)
        healthLabel.TextColor3 = Color3.new(0, 1, 0)
        healthLabel.TextStrokeTransparency = 0
        healthLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
        healthLabel.Font = Enum.Font.Code
        healthLabel.TextSize = 12
        healthLabel.Parent = billboard
        local humanoid = char:WaitForChild("Humanoid")
        local function updateHealth()
            local h = humanoid.Health
            local mh = humanoid.MaxHealth
            healthLabel.Text = string.format("Health: %.0f/%.0f", h, mh)
            healthLabel.TextColor3 = (h / mh < 0.5) and Color3.new(1, 0, 0) or Color3.new(0, 1, 0)
        end
        updateHealth()
        humanoid.HealthChanged:Connect(updateHealth)
        humanoid.Died:Connect(function()  -- Added this to ensure removal on death, fixing the intermittent display issue
            removeESP(char)
        end)
        local box = Drawing.new("Square")
        box.Visible = false
        box.Color = Color3.fromRGB(0, 0, 255)
        box.Thickness = 2
        box.Filled = false
        box.Transparency = 0.7
        ESPObjects[char] = {highlight = highlight, billboard = billboard, box = box}
    end
    local function removeESP(char)
        if ESPObjects[char] then
            ESPObjects[char].highlight:Destroy()
            ESPObjects[char].billboard:Destroy()
            ESPObjects[char].box:Remove()
            ESPObjects[char] = nil
        end
    end
    RunService.RenderStepped:Connect(function()
        for char, obj in pairs(ESPObjects) do
            if char and char.Parent and obj.box then
                local hrp = char:FindFirstChild("HumanoidRootPart")
                local head = char:FindFirstChild("Head")
                if hrp and head then
                    local headPos, onScreen = Camera:WorldToViewportPoint(head.Position)
                    local legPos = Camera:WorldToViewportPoint(hrp.Position - Vector3.new(0, 4, 0))
                    if onScreen then
                        local height = math.abs(headPos.Y - legPos.Y)
                        local width = height * 0.4
                        obj.box.Size = Vector2.new(width, height)
                        obj.box.Position = Vector2.new(headPos.X - width / 2, headPos.Y)
                        obj.box.Visible = true
                    else
                        obj.box.Visible = false
                    end
                else
                    obj.box.Visible = false
                end
            end
        end
    end)
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr.Character then addESP(plr.Character) end
        plr.CharacterAdded:Connect(addESP)
        plr.CharacterRemoving:Connect(removeESP)
    end
    Players.PlayerAdded:Connect(function(plr)
        plr.CharacterAdded:Connect(addESP)
        plr.CharacterRemoving:Connect(removeESP)
    end)
    Players.PlayerRemoving:Connect(function(plr)
        if plr.Character then removeESP(plr.Character) end
    end)
    print("ESP loaded")
    -- Camlock (C to toggle)
    local camlockEnabled = false
    local currentTarget = nil
    local Mouse = LocalPlayer:GetMouse()
    local tracer = Drawing.new("Line")
    tracer.Color = Color3.fromRGB(0, 255, 0)
    tracer.Thickness = 3
    tracer.Transparency = 0.6
    tracer.Visible = false
    local targetPart = "Head"
    local function isValidTarget(plr)
        local char = plr.Character
        if not char then return false end
        local hum = char:FindFirstChildOfClass("Humanoid")
        if not hum or hum.Health <= 0 then return false end  -- Changed from <=1 to <=0 as requested
        local be = char:FindFirstChild("BodyEffects")
        if be and be:FindFirstChild("K.O") and be["K.O"].Value then return false end
        if char:FindFirstChild("GRABBING_CONSTRAINT") then return false end
        return true
    end
    local function getClosestPlayer()
        local closest = nil
        local shortest = math.huge
        local mousePos = Vector2.new(Mouse.X, Mouse.Y)
        for _, plr in pairs(Players:GetPlayers()) do
            if plr ~= LocalPlayer and isValidTarget(plr) then
                local part = plr.Character:FindFirstChild(targetPart)
                if part then
                    local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                    if onScreen then
                        local dist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                        if dist < shortest then
                            shortest = dist
                            closest = plr
                        end
                    end
                end
            end
        end
        return closest
    end
    UserInputService.InputBegan:Connect(function(input)
        if input.KeyCode == Enum.KeyCode.C then
            camlockEnabled = not camlockEnabled
            tracer.Visible = camlockEnabled
            currentTarget = nil
            if camlockEnabled then
                local tgt = getClosestPlayer()
                if tgt then
                    currentTarget = tgt
                    StarterGui:SetCore("SendNotification", {
                        Title = "Camlock",
                        Text = "Locked: " .. tgt.Name,
                        Duration = 2.5
                    })
                else
                    StarterGui:SetCore("SendNotification", {
                        Title = "Camlock",
                        Text = "No valid target nearby",
                        Duration = 1.5
                    })
                end
            end
            print("Camlock:", camlockEnabled and "ON" or "OFF")
        end
    end)
    RunService.RenderStepped:Connect(function()
        if not camlockEnabled or not currentTarget then
            tracer.Visible = false
            return
        end
        if not isValidTarget(currentTarget) then
            currentTarget = nil
            tracer.Visible = false
            StarterGui:SetCore("SendNotification", {Title = "Camlock", Text = "Target dead/released", Duration = 1.5})
            return
        end
        local part = currentTarget.Character:FindFirstChild(targetPart)
        if part then
            Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, part.Position)
            local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
            if onScreen then
                tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                tracer.To = Vector2.new(screenPos.X, screenPos.Y)
                tracer.Visible = true
            else
                tracer.Visible = false
            end
        else
            tracer.Visible = false
        end
    end)
    print("Camlock (C to toggle) loaded")
    print("Speed (V toggle) & Super Jump (Z hold) loaded")
    print("ESP loaded")
    print("All features activated successfully!")
end
print("heil ukraina!")

	--hitbox
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

_G.Enabled = true
_G.BaseSize = 2
_G.MaxSize = 150      -- Max hitbox size
_G.DistanceForMax = 1000  -- Full 150 at 1000 studs
_G.Transparency = 1   -- Fully invisible
_G.Prediction = 0.138

local originalSizes = {}
local originalMaterials = {}
local originalColors = {}

local tracer = Drawing.new("Line")
tracer.Thickness = 2
tracer.Transparency = 0.45
tracer.Color = Color3.fromRGB(0, 0, 139)  -- Dark blue as requested
tracer.Visible = false

UserInputService.InputBegan:Connect(function(inp, gp)
    if gp then return end
    if inp.KeyCode == Enum.KeyCode.P then
        _G.Enabled = not _G.Enabled
        print(_G.Enabled and "hitbox load")
    end
end)

local function worldToScreen(point)
    local screenPos, onScreen = Camera:WorldToViewportPoint(point)
    return Vector2.new(screenPos.X, screenPos.Y), onScreen, screenPos.Z
end

local function getClosestVisiblePlayer()
    local closestPlayer = nil
    local closestDist = math.huge

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local head = player.Character:FindFirstChild("Head") or player.Character:FindFirstChild("UpperTorso") or player.Character.PrimaryPart
            if head then
                local predPos = head.Position + (head.AssemblyLinearVelocity or Vector3.zero) * _G.Prediction
                local screenPos, onScreen = worldToScreen(predPos)
                if onScreen then
                    local dist = (screenPos - Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)).Magnitude
                    if dist < closestDist and isVisible(head) then
                        closestDist = dist
                        closestPlayer = player
                    end
                end
            end
        end
    end
    return closestPlayer
end

function isVisible(targetPart)
    if not targetPart then return false end
    local origin = Camera.CFrame.Position
    local direction = (targetPart.Position - origin) * 1000  -- Longer ray for reliability
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Exclude
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character}
    rayParams.IgnoreWater = true
    
    local result = workspace:Raycast(origin, direction, rayParams)
    if result then
        local hitPart = result.Instance
        local hitModel = hitPart:FindFirstAncestorWhichIsA("Model")
        if hitModel and hitModel:FindFirstChild("Humanoid") and Players:GetPlayerFromCharacter(hitModel) then
            return true
        end
        return false
    end
    return true
end

local function updateTracerToTarget(targetPart)
    if not targetPart then
        tracer.Visible = false
        return
    end

    local mousePos = UserInputService:GetMouseLocation()
    local velocity = targetPart.AssemblyLinearVelocity or Vector3.zero
    local predPos = targetPart.Position + velocity * _G.Prediction
    local screenPos, onScreen = worldToScreen(predPos)

    if onScreen then
        tracer.From = mousePos
        tracer.To = screenPos
        tracer.Color = Color3.fromRGB(0, 0, 139)  -- Dark blue locked color
        tracer.Visible = true
    else
        tracer.Visible = false
    end
end

local function resetHitbox(part)
    if not part then return end
    if originalSizes[part] then
        part.Size = originalSizes[part]
        originalSizes[part] = nil
    end
    if originalMaterials[part] then
        part.Material = originalMaterials[part]
        originalMaterials[part] = nil
    end
    if originalColors[part] then
        part.Color = originalColors[part]
        originalColors[part] = nil
    end
    part.Transparency = 0
    part.CanCollide = true
end

RunService.Heartbeat:Connect(function()
    if not _G.Enabled or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        tracer.Visible = false
        for part in pairs(originalSizes) do resetHitbox(part) end
        return
    end

    for part in pairs(originalSizes) do resetHitbox(part) end
    originalSizes = {}
    originalMaterials = {}
    originalColors = {}

    local targetPlayer = getClosestVisiblePlayer()
    local targetRoot = nil
    local targetPart = nil  -- For tracer (head or equivalent)

    if targetPlayer and targetPlayer.Character then
        targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart") or targetPlayer.Character:FindFirstChild("Torso") or targetPlayer.Character.PrimaryPart
        targetPart = targetPlayer.Character:FindFirstChild("Head") or targetPlayer.Character:FindFirstChild("UpperTorso") or targetRoot
        
        if targetRoot and targetPart then
            originalSizes[targetRoot] = targetRoot.Size
            originalMaterials[targetRoot] = targetRoot.Material or Enum.Material.Plastic
            originalColors[targetRoot] = targetRoot.Color or Color3.new(1,1,1)

            local myPos = LocalPlayer.Character.HumanoidRootPart.Position
            local distance = (myPos - targetRoot.Position).Magnitude
            local scaleFactor = math.clamp(distance / _G.DistanceForMax, 0, 1)
            local dynamicSize = _G.BaseSize + (_G.MaxSize - _G.BaseSize) * scaleFactor
            local newSize = Vector3.new(dynamicSize, dynamicSize, dynamicSize)

            targetRoot.Size = newSize
            targetRoot.Transparency = _G.Transparency
            targetRoot.CanCollide = false
            targetRoot.Material = originalMaterials[targetRoot]
            targetRoot.Color = originalColors[targetRoot]
        end
    end

    if targetPart then
        updateTracerToTarget(targetPart)
    else
        tracer.Visible = false
    end
end)

spawn(function()
    while wait(1) do
        if not _G.Enabled then
            tracer.Visible = false
            for part in pairs(originalSizes) do resetHitbox(part) end
        end
    end
end)
print("hitbox loaded P to toggle") 
