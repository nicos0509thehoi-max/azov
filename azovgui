--meow
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local CoreGui = game:GetService("CoreGui")
local StarterGui = game:GetCore("StarterGui")
local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()

-- KEY SYSTEM
local CORRECT_KEY = "azv" 
local KeyGui = Instance.new("ScreenGui")
KeyGui.Name = "KeySystemGui"
KeyGui.Parent = CoreGui
KeyGui.ResetOnSpawn = false

local MainFrame = Instance.new("Frame")
MainFrame.Parent = KeyGui
MainFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
MainFrame.Size = UDim2.new(0, 600, 0, 300)
MainFrame.Position = UDim2.new(0.5, -300, 0.5, -150)
MainFrame.ClipsDescendants = true

local TitleBar = Instance.new("Frame")
TitleBar.Parent = MainFrame
TitleBar.BackgroundColor3 = Color3.fromRGB(10, 10, 10)
TitleBar.Size = UDim2.new(1, 0, 0, 28)
TitleBar.Active = true

local TitleText = Instance.new("TextLabel")
TitleText.Parent = TitleBar
TitleText.BackgroundTransparency = 1
TitleText.Size = UDim2.new(0, 150, 1, 0)
TitleText.Position = UDim2.new(0, 10, 0, 0)
TitleText.Text = "Azov .gg/cack5ZaXrE"
TitleText.Font = Enum.Font.SourceSansBold
TitleText.TextColor3 = Color3.fromRGB(255, 255, 255)
TitleText.TextSize = 18

local CloseButton = Instance.new("TextButton")
CloseButton.Parent = TitleBar
CloseButton.Size = UDim2.new(0, 40, 0, 28)
CloseButton.Position = UDim2.new(1, -40, 0, 0)
CloseButton.BackgroundTransparency = 1
CloseButton.Text = "X"
CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseButton.TextSize = 18
CloseButton.MouseButton1Click:Connect(function()
    KeyGui:Destroy()
end)

local AsciiArt = Instance.new("TextLabel")
AsciiArt.Parent = MainFrame
AsciiArt.BackgroundTransparency = 1
AsciiArt.Size = UDim2.new(1, 0, 0.6, 0)
AsciiArt.Position = UDim2.new(0, 0, 0.12, 0)
AsciiArt.Font = Enum.Font.Code
AsciiArt.Text = [[
 (`-')  _   (`-')                   (`-')
 (OO ).-/   ( OO).->    .->        _(OO )
 / ,---.  ,(_/----.(`-')----. ,--.(_/,-.\
 | \ /`.\ |__,    |( OO).-.  '\   \ / (_/
 '-'_|.' | (_/   / ( _) | |  | \   /   / 
(|  .-.  | .'  .' _ \|  |)|  |_ \     /_)
 |  | |  ||       |  '  '-'  '\-'\   /   
 `--' `--'`-------'   `-----'     `-'    
]]
AsciiArt.TextColor3 = Color3.fromRGB(112, 0, 0)
AsciiArt.TextSize = 12
AsciiArt.TextWrapped = true
AsciiArt.TextXAlignment = Enum.TextXAlignment.Center

local KeyLabel = Instance.new("TextLabel")
KeyLabel.Parent = MainFrame
KeyLabel.BackgroundTransparency = 1
KeyLabel.Position = UDim2.new(0, 30, 0, 200)
KeyLabel.Size = UDim2.new(0.7, 0, 0.1, 0)
KeyLabel.Font = Enum.Font.Code
KeyLabel.RichText = true
KeyLabel.TextColor3 = Color3.fromRGB(128, 128, 128)
KeyLabel.TextSize = 14
KeyLabel.TextXAlignment = Enum.TextXAlignment.Left

-- Dragging
local dragging, dragInput, dragStart, startPos
TitleBar.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = MainFrame.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then dragging = false end
        end)
    end
end)

TitleBar.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and input == dragInput then
        local delta = input.Position - dragStart
        MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)

-- Key system logic
local typedKey = ""
local showCursor = true
local canType = false
local authenticated = false

local function updateLabel()
    local cursor = showCursor and "â–„" or ""
    KeyLabel.Text = string.format('[<font color="rgb(255,0,0)">-</font>] Key: <font color="rgb(128,128,128)">%s</font><font color="rgb(255,255,255)">%s</font>', typedKey, cursor)
end

task.spawn(function()
    while not authenticated do
        showCursor = not showCursor
        updateLabel()
        task.wait(0.5)
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if canType and input.UserInputType == Enum.UserInputType.Keyboard then
        if input.KeyCode == Enum.KeyCode.Return then
            canType = false
            if typedKey:lower() == CORRECT_KEY:lower() then
                authenticated = true
                KeyLabel.Text = '[<font color="rgb(0,255,0)">+</font>] Authenticating...'
                task.wait(2)
                local function fade(gui, dur)
                    for _, o in ipairs(gui:GetDescendants()) do
                        if o:IsA("GuiObject") then
                            TweenService:Create(o, TweenInfo.new(dur), {Transparency = 1, BackgroundTransparency = 1}):Play()
                            if o:IsA("TextLabel") or o:IsA("TextButton") then
                                TweenService:Create(o, TweenInfo.new(dur), {TextTransparency = 1}):Play()
                            end
                        end
                    end
                end
                fade(KeyGui, 1.5)
                task.wait(1.5)
                KeyGui:Destroy()
                print("Key accepted! Loading full script...")
                loadFeatures()
            else
                LocalPlayer:Kick("Invalid Key")
            end
        elseif input.KeyCode == Enum.KeyCode.Backspace then
            typedKey = typedKey:sub(1, -2)
        else
            local name = input.KeyCode.Name
            if #name == 1 then
                typedKey = typedKey .. name:lower()
            end
        end
        updateLabel()
    end
end)

UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType ~= Enum.UserInputType.MouseButton1 and input.UserInputType ~= Enum.UserInputType.Touch then return end
    local pos = input.Position
    local absPos = KeyLabel.AbsolutePosition
    local absSize = KeyLabel.AbsoluteSize
    if pos.X >= absPos.X and pos.X <= absPos.X + absSize.X and pos.Y >= absPos.Y and pos.Y <= absPos.Y + absSize.Y then
        canType = true
        typedKey = ""
        updateLabel()
    else
        canType = false
        updateLabel()
    end
end)

updateLabel()

function loadFeatures()
    local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/xHeptc/Kavo-UI-Library/main/source.lua"))()
    local Window = Library.CreateLib("Azov Brigade", "BloodTheme")

    local UITab = Window:NewTab("UI")
    local UISection = UITab:NewSection("Toggle")
    UISection:NewKeybind("Toggle UI", "Opens/Closes the menu", Enum.KeyCode.RightShift, function()
        Library:ToggleUI()
    end)

    local MainTab = Window:NewTab("Main")
    local FeaturesSection = MainTab:NewSection("Features")
    local CamlockSection = MainTab:NewSection("Camlock Only (C Key)")
    local TriggerCamSection = MainTab:NewSection("Triggerbot + Camlock (U Key)")

    -- Movement
    local SpeedEnabled = false
    local superJumpEnabled = false

    local function updateHumanoid()
        local char = LocalPlayer.Character
        if char then
            local hum = char:FindFirstChildOfClass("Humanoid")
            if hum then
                hum.WalkSpeed = SpeedEnabled and AZOV_CONFIG.SUPER_SPEED or 16
                hum.JumpPower = superJumpEnabled and AZOV_CONFIG.SUPER_JUMP or 50
            end
        end
    end

    LocalPlayer.CharacterAdded:Connect(function(char)
        local hum = char:WaitForChild("Humanoid")
        hum.WalkSpeed = 16
        hum.JumpPower = 50
        updateHumanoid()
    end)

    RunService.RenderStepped:Connect(updateHumanoid)

    FeaturesSection:NewKeybind("Super Speed Toggle", "V Key", Enum.KeyCode.V, function()
        SpeedEnabled = not SpeedEnabled
        StarterGui:SetCore("SendNotification", {Title = "Super Speed", Text = SpeedEnabled and "ON" or "OFF", Duration = 2})
    end)

    FeaturesSection:NewKeybind("Super Jump Toggle", "Z Key", Enum.KeyCode.Z, function()
        superJumpEnabled = not superJumpEnabled
        StarterGui:SetCore("SendNotification", {Title = "Super Jump", Text = superJumpEnabled and "ON" or "OFF", Duration = 2})
    end)

    -- ESP Load Keybind (F2)
    FeaturesSection:NewKeybind("Load ESP (F2)", "F2", Enum.KeyCode.F2, function()
        local espUrl = "https://raw.githubusercontent.com/nicos0509thehoi-max/esp/refs/heads/main/esp%20obfuscation.lua"
        loadstring(game:HttpGet(espUrl))()
        StarterGui:SetCore("SendNotification", {Title = "ESP", Text = "ESP script loaded", Duration = 3})
    end)

    -- TRIGGERBOT + CAMLOCK (U Key)
    local triggerCamlockEnabled = false
    TriggerCamSection:NewKeybind("Triggerbot + Camlock Toggle", "U Key", Enum.KeyCode.U, function()
        triggerCamlockEnabled = not triggerCamlockEnabled
        StarterGui:SetCore("SendNotification", {Title = "Triggerbot + Camlock", Text = triggerCamlockEnabled and "ON" or "OFF", Duration = 2})
    end)

    local currentTarget = nil
    local lastFireTime = 0

    local function isValidTarget(plr)
        local char = plr.Character
        if not char then return false end
        local hum = char:FindFirstChildOfClass("Humanoid")
        if not hum or hum.Health <= 0 then return false end
        local be = char:FindFirstChild("BodyEffects")
        if be and be:FindFirstChild("K.O") and be["K.O"].Value then return false end
        if char:FindFirstChild("GRABBING_CONSTRAINT") then return false end
        return true
    end

    local function isMouseOverEnemy()
        local target = Mouse.Target
        if target then
            local model = target:FindFirstAncestorWhichIsA("Model")
            if model and model:FindFirstChild("Humanoid") then
                local plr = Players:GetPlayerFromCharacter(model)
                if plr and plr ~= LocalPlayer and isValidTarget(plr) then
                    return plr
                end
            end
        end
        return nil
    end

    RunService.RenderStepped:Connect(function()
        if not triggerCamlockEnabled then return end
        local hoveredEnemy = isMouseOverEnemy()
        if hoveredEnemy then
            currentTarget = hoveredEnemy
            local part = currentTarget.Character:FindFirstChild(AZOV_CONFIG.TARGET_PART)
            if part then
                local velocity = part.AssemblyLinearVelocity or Vector3.new(0,0,0)
                local predictedPos = part.Position + (velocity * (AZOV_CONFIG.TRIGGER_PREDICTION / 1000))
                local currentCFrame = Camera.CFrame
                local targetCFrame = CFrame.lookAt(currentCFrame.Position, predictedPos)
                Camera.CFrame = currentCFrame:Lerp(targetCFrame, 1 - (AZOV_CONFIG.TRIGGER_SMOOTHNESS / 1000))
            end
            if tick() - lastFireTime > AZOV_CONFIG.TRIGGER_DELAY then
                mouse1press()
                task.wait(0.01)
                mouse1release()
                lastFireTime = tick()
            end
        else
            currentTarget = nil
        end
    end)

    -- CAMLOCK ONLY - STICKY (C Key)
    local camlockOnlyEnabled = false
    local camlockOnlyTarget = nil

    CamlockSection:NewToggle("Camlock Only (Sticky)", "Locks until target dies or toggle off", function(state)
        camlockOnlyEnabled = state
        StarterGui:SetCore("SendNotification", {
            Title = "Camlock Only",
            Text = camlockOnlyEnabled and "ON (Sticky Mode)" or "OFF",
            Duration = 2
        })
        if not camlockOnlyEnabled then
            camlockOnlyTarget = nil
        end
    end)

    CamlockSection:NewKeybind("Toggle Camlock Only", "C Key", Enum.KeyCode.C, function()
        camlockOnlyEnabled = not camlockOnlyEnabled
        StarterGui:SetCore("SendNotification", {
            Title = "Camlock Only",
            Text = camlockOnlyEnabled and "ON (Sticky Mode)" or "OFF",
            Duration = 2
        })
        if not camlockOnlyEnabled then
            camlockOnlyTarget = nil
        end
    end)

    RunService.RenderStepped:Connect(function()
        if not camlockOnlyEnabled then return end

        if not camlockOnlyTarget or not camlockOnlyTarget.Parent or not isValidTarget(Players:GetPlayerFromCharacter(camlockOnlyTarget.Parent)) then
            local hoveredEnemy = isMouseOverEnemy()
            if hoveredEnemy then
                camlockOnlyTarget = hoveredEnemy.Character:FindFirstChild(AZOV_CONFIG.TARGET_PART)
                if camlockOnlyTarget then
                    StarterGui:SetCore("SendNotification", {
                        Title = "Camlock Target",
                        Text = "Locked onto: " .. hoveredEnemy.Name,
                        Duration = 3
                    })
                end
            end
        end

        if camlockOnlyTarget and camlockOnlyTarget.Parent then
            local velocity = camlockOnlyTarget.AssemblyLinearVelocity or Vector3.new(0,0,0)
            local predictedPos = camlockOnlyTarget.Position + (velocity * (AZOV_CONFIG.CAMLOCK_ONLY_PREDICTION / 1000))
            local currentCFrame = Camera.CFrame
            local targetCFrame = CFrame.lookAt(currentCFrame.Position, predictedPos)
            Camera.CFrame = currentCFrame:Lerp(targetCFrame, 1 - (AZOV_CONFIG.CAMLOCK_ONLY_SMOOTHNESS / 1000))
        end
    end)

    -- Hitbox Expander
    _G.HitboxEnabled = false  -- Default off, toggle with P
    FeaturesSection:NewKeybind("Hitbox Expander Toggle", "P Key", Enum.KeyCode.P, function()
        _G.HitboxEnabled = not _G.HitboxEnabled
        StarterGui:SetCore("SendNotification", {Title = "Hitbox", Text = _G.HitboxEnabled and "ON" or "OFF", Duration = 2})
    end)

    local originalSizes = {}
    local originalMaterials = {}
    local originalColors = {}
    local hitboxTracer = Drawing.new("Line")
    hitboxTracer.Color = Color3.fromRGB(0, 0, 139)
    hitboxTracer.Thickness = 2
    hitboxTracer.Transparency = 0.45
    hitboxTracer.Visible = false

    local function worldToScreen(point)
        local screenPos, onScreen = Camera:WorldToViewportPoint(point)
        return Vector2.new(screenPos.X, screenPos.Y), onScreen
    end

    local function getClosestVisiblePlayer()
        local closestPlayer = nil
        local closestDist = math.huge

        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character then
                local head = player.Character:FindFirstChild("Head") or player.Character:FindFirstChild("UpperTorso") or player.Character.PrimaryPart
                if head then
                    local predPos = head.Position + (head.AssemblyLinearVelocity or Vector3.zero) * (AZOV_CONFIG.TRIGGER_PREDICTION / 1000)
                    local screenPos, onScreen = worldToScreen(predPos)
                    if onScreen then
                        local dist = (screenPos - Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)).Magnitude
                        if dist < closestDist and isVisible(head) then
                            closestDist = dist
                            closestPlayer = player
                        end
                    end
                end
            end
        end
        return closestPlayer
    end

    function isVisible(targetPart)
        if not targetPart then return false end
        local origin = Camera.CFrame.Position
        local direction = targetPart.Position - origin
        local rayParams = RaycastParams.new()
        rayParams.FilterType = Enum.RaycastFilterType.Exclude
        rayParams.FilterDescendantsInstances = {LocalPlayer.Character, targetPart.Parent}
        rayParams.IgnoreWater = true
        local result = workspace:Raycast(origin, direction, rayParams)
        return not result
    end

    local function updateHitboxTracer(targetPart)
        if not targetPart then
            hitboxTracer.Visible = false
            return
        end
        local mousePos = UserInputService:GetMouseLocation()
        local velocity = targetPart.AssemblyLinearVelocity or Vector3.zero
        local predPos = targetPart.Position + velocity * (AZOV_CONFIG.TRIGGER_PREDICTION / 1000)
        local screenPos, onScreen = worldToScreen(predPos)
        if onScreen then
            hitboxTracer.From = mousePos
            hitboxTracer.To = screenPos
            hitboxTracer.Visible = true
        else
            hitboxTracer.Visible = false
        end
    end

    local function resetHitbox(part)
        if not part then return end
        if originalSizes[part] then part.Size = originalSizes[part] originalSizes[part] = nil end
        if originalMaterials[part] then part.Material = originalMaterials[part] originalMaterials[part] = nil end
        if originalColors[part] then part.Color = originalColors[part] originalColors[part] = nil end
        part.Transparency = 1
        part.CanCollide = true
    end

    local currentTargetRoot = nil
    RunService.Heartbeat:Connect(function()
        if not _G.HitboxEnabled or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            hitboxTracer.Visible = false
            if currentTargetRoot then resetHitbox(currentTargetRoot) currentTargetRoot = nil end
            return
        end

        if currentTargetRoot then resetHitbox(currentTargetRoot) currentTargetRoot = nil end

        local targetPlayer = getClosestVisiblePlayer()
        local targetRoot = nil
        local targetPart = nil

        if targetPlayer and targetPlayer.Character then
            targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart") or targetPlayer.Character:FindFirstChild("Torso") or targetPlayer.Character.PrimaryPart
            targetPart = targetPlayer.Character:FindFirstChild(AZOV_CONFIG.TARGET_PART) or targetRoot
            if targetRoot and targetPart then
                originalSizes[targetRoot] = targetRoot.Size
                originalMaterials[targetRoot] = targetRoot.Material or Enum.Material.Plastic
                originalColors[targetRoot] = targetRoot.Color or Color3.new(1,1,1)

                local myPos = LocalPlayer.Character.HumanoidRootPart.Position
                local distance = (myPos - targetRoot.Position).Magnitude
                local scaleFactor = math.clamp(distance / AZOV_CONFIG.HITBOX_SCALE_DISTANCE, 0, 1)
                local dynamicSize = AZOV_CONFIG.HITBOX_MIN_SIZE + (AZOV_CONFIG.HITBOX_MAX_SIZE - AZOV_CONFIG.HITBOX_MIN_SIZE) * (1 - scaleFactor)

                targetRoot.Size = Vector3.new(dynamicSize, dynamicSize, dynamicSize)
                targetRoot.Transparency = 1
                targetRoot.CanCollide = false
                currentTargetRoot = targetRoot
            end
        end

        updateHitboxTracer(targetPart)
    end)
end

StarterGui:SetCore("SendNotification", {Title = "Azov V2", Text = "load success", Duration = 5})
